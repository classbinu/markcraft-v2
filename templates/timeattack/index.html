{% extends "layout/base.html" %}
<!-- ë ˆì´ì•„ì›ƒ -->
{% block body %}
<!-- ë„¤ë¹„ê²Œì´ì…˜ë°” -->
{% include 'common/navbar.html' %}
<style>
  #currentTime {
    width: 15rem;
  }
</style>
<link rel="stylesheet" type="text/css" href="/static/markdown.css" />
<main class="container mx-auto p-5">
  <h1 class="text-center text-3xl font-bold logo text-markcraft">íƒ€ì„ì–´íƒ</h1>
  <div class="flex justify-center">
    <p id="currentTime" class="text-6xl mt-10 mb-5">00:00:00</p>
  </div>
  <div>
    <!-- ê¸°ë¡ ë¹„êµë¥¼ ìœ„í•œ ê¸°ì¡´ ê¸°ë¡ ìˆ¨ê¹€ -->
    <div class="hidden">
      <input id="bestTime" type="number" value="{{ bestTime }}" />
      <input id="myBestTime" type="number" value="{{ myBestTime }}" />
    </div>
    <div class="text-gray-400 mb-5 w-60 mx-auto">
      <ol>
        <li class="text-primary font-bold">
          <span class="text-2xl">ğŸ¥‡</span> {{ ranker_1.nickname }} {{
          ranker_1.bestTime }}
        </li>
        <li class="text-secondary">
          <span class="text-2xl">ğŸ¥ˆ</span> {{ ranker_2.nickname }} {{
          ranker_2.bestTime }}
        </li>
        <li class="text-accent">
          <span class="text-2xl">ğŸ¥‰</span> {{ ranker_3.nickname }} {{
          ranker_3.bestTime }}
        </li>
        <li class="text-success">
          <span class="text-2xl">ğŸ…</span> ë‚´ ìµœê³  ê¸°ë¡ {{ formattedMyBestTime
          }}
        </li>
      </ol>
    </div>
  </div>

  <div class="text-center">
    <progress id="progress-bar" class="progress progress-success w-56" value="0" max="5"></progress>
    <p id="progress-text" class="text-gray-400">0/5</p>
  </div>
  <div class="flex flex-wrap">
    <div class="w-full lg:w-1/2 lg:px-20">
      <p class="text-center fond-bold text-xl my-5">ë§ˆí¬ë‹¤ìš´ì„ ì‘ì„±í•˜ì„¸ìš”</p>
      <textarea id="answer" class="w-full textarea textarea-success h-36" oninput="checkAnswer()" autofocus></textarea>
    </div>
    <div class="w-full lg:w-1/2 lg:px-20">
      <p class="text-center fond-bold text-xl my-5">ì´ í™”ë©´ì„ êµ¬í˜„í•˜ì„¸ìš”</p>
      <input id="question" class="border-2 p-5 border-success rounded-xl h-36 hidden" />
      <div id="previewOutput" class="border-2 p-5 border-success rounded-xl h-36"></div>
    </div>
  </div>
  <div class="text-center">
    <button id="startBtn" class="btn btn-success text-white btn-lg my-10" onclick="startTimeAttack()">
      ì‹œì‘ â°
    </button>
    <button id="quitBtn" class="btn btn-error text-white btn-lg my-10 hidden" onclick="location.reload()">
      í¬ê¸° ğŸ˜¥
    </button>
    <!-- <button id="quitBtn" class="btn btn-error text-white btn-lg my-10 hidden" onclick="location.reload()">
      í¬ê¸° ğŸ˜¥
    </button> -->
  </div>
  <!-- <ul class="">
    {% for question in questions %}
    <li id="question_{{ loop.index }}">{{ question }}</li>
    {% endfor %}
  </ul> -->
  <input id="test_set" value="{{ questions }}" hidden />
  <input id="test_set_html" value="{{html_questions}}" hidden />
</main>

<script>
  let answerCount = 0;
  let testSet = [];
  const bestTime = document.getElementById("bestTime").value;
  const myBestTime = document.getElementById("myBestTime").value;
  const testSetText = document.getElementById("test_set").value;

  function startTimeAttack() {
    const question = document.getElementById("question");
    const previewOutput = document.getElementById("previewOutput");
    console.log(testSetText);
    testSet = testSetText.replace(/[\[\]']+/g, "").split(", ");
    // '\\n'ì„ '\n'ìœ¼ë¡œ ë°”ê¾¸ê¸°
    testSet = testSet.map((s) => s.replace(/\\n/g, "\n"));
    testSet = testSet.map((s) => marked(s));
    console.log(testSet);
    // console.log(testHtmlSetlText);
    // htmlSet = testHtmlSetlText.replace(/[\[\]']+/g, "").split(", ");
    // console.log(htmlSet);
    // testSet = testSetText.replace(/[\[\]']+/g, "").split(", ");

    // ìµœì´ˆ 1ë²ˆ ë¬¸ì œ ì„¸íŒ…
    const answer = document.getElementById("answer");
    answer.focus();
    question.value = testSet[answerCount];
    // previewOutput.innerHTML = testSet[answerCount];
    markdownStaticRendering();
    // console.log(marked(question.value))
    // console.log(previewOutput.innerHTML)
    // ë²„íŠ¼ ë³€ê²½
    const startBtnEl = document.getElementById("startBtn");
    const quitBtnEl = document.getElementById("quitBtn");
    startBtnEl.classList.add("hidden");
    quitBtnEl.classList.remove("hidden");

    startTimer();
  }

  function checkAnswer() {
    let question = document.getElementById("previewOutput");
    let answer = document.getElementById("answer");
    console.log(answer.value);
    // const chapter_id = parseInt(document.getElementById("chapter_id").innerText);
    question = question.innerHTML;
    let value = marked(answer.value);
    // ê°œí–‰ë¬¸ì ì œê±°
    value = value.replace(/\n/g, "");
    answer = value;
    console.log(question);
    console.log(answer);
    console.log(question == answer);
    if (question == answer) {
      Swal.fire({
        position: "center",
        icon: "success",
        title: `[${answerCount + 1}/5] ì •ë‹µì…ë‹ˆë‹¤!`,
        showConfirmButton: false,
        timer: 1000,
      });
      setTimeout(() => {
        let question = document.getElementById("question");
        let answer = document.getElementById("answer");
        answerCount++;
        question.value = testSet[answerCount];
        // previewOutput.value = testSet[answerCount];
        markdownStaticRendering();
        console.log(question.value);
        console.log(previewOutput.innerHTML);
        answer.value = "";
        checkPassedTimeattack();
        updateProgressBar();
      }, 1000);
    }
  }

  function checkPassedTimeattack() {
    let conditionalMessage = "";
    if (answerCount === 5) {
      stopTimer();
      postMyTime(myTime);
      const bestTime = document.getElementById("bestTime").value;
      const myBestTime = document.getElementById("myBestTime").value;
      if (myTime < bestTime) {
        conditionalMessage = "ğŸ‰ ì„œë²„ ìµœê³  ê¸°ë¡ì„ ê²½ì‹ í–ˆì–´ìš” ğŸ‘";
      } else if (myTime < myBestTime) {
        conditionalMessage = "ğŸ”¥ ê°œì¸ ìµœê³  ê¸°ë¡ì„ ê²½ì‹ í–ˆì–´ìš” ğŸ‘";
      }
      Swal.fire({
        title: `íƒ€ì„ì–´íƒ ì„±ê³µ<br>${convertTimeFormat(
          myTime
        )}<br>${conditionalMessage}`,
        width: 600,
        padding: "3em",
        color: "#716add",
        // background: "#fff url(/images/trees.png)",
        backdrop: `
    rgba(0,0,123,0.4)
    url("https://sweetalert2.github.io/images/nyan-cat.gif")
    left top
    no-repeat
  `,
      }).then((result) => {
        if (result.isConfirmed) {
          window.location.reload();
        }
      });
    }
  }

  // íƒ€ì´ë¨¸ ê´€ë ¨ ë³€ìˆ˜
  let timerInterval;
  let startTime;
  let myTime;
  let timeDisplay = document.getElementById("currentTime");

  // íƒ€ì´ë¨¸ ì‘ë™ ì‹œì‘
  function startTimer() {
    startTime = Date.now();
    timerInterval = setInterval(function () {
      myTime = Date.now() - startTime;
      timeDisplay.textContent = convertTimeFormat(myTime);
    }, 10);
  }

  // íƒ€ì´ë¨¸ ì‘ë™ ì¤‘ì§€
  function stopTimer() {
    clearInterval(timerInterval);
    timerInterval = null;
  }

  // íƒ€ì„ì–´íƒ ì§„í–‰ ì‹œê°„ í¬ë§·íŒ…
  function convertTimeFormat(milliseconds) {
    let minutes = Math.floor(milliseconds / (60 * 1000));
    let seconds = Math.floor((milliseconds % (60 * 1000)) / 1000);
    let milliseconds2 = Math.floor((milliseconds % 1000) / 10);

    return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(
      2,
      "0"
    )}:${String(milliseconds2).padStart(2, "0")}`;
  }

  // í”„ë¡œê·¸ë ˆìŠ¤ë°” ì—…ë°ì´íŠ¸
  function updateProgressBar() {
    const progressBar = document.getElementById("progress-bar");
    progressBar.max = testSet.length;
    progressBar.value = answerCount;

    const progressText = document.getElementById("progress-text");
    progressText.textContent = `${answerCount}/${testSet.length}`;
  }

  // íƒ€ì„ì–´íƒ ë‚´ ê¸°ë¡ ì—…ë°ì´íŠ¸í•˜ê¸°
  async function postMyTime(myTime) {
    const url = "/timeattack";

    const options = {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ myTime }),
    };

    try {
      const response = await fetch(url, options);

      if (!response.ok) {
        throw new Error("ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë°œìƒ");
      }

      const data = await response.json();
      console.log("ì„œë²„ ì‘ë‹µ:", data);
    } catch (error) {
      console.error("ì˜¤ë¥˜ ë°œìƒ:", error);
    }
  }
</script>
{% endblock %}